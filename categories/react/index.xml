<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>react on VISIONARY BLOG</title><link>https://blog.visionary.top/categories/react/</link><description>Recent content in react on VISIONARY BLOG</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 16 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.visionary.top/categories/react/index.xml" rel="self" type="application/rss+xml"/><item><title>react 一些不常用API的示例</title><link>https://blog.visionary.top/blog/react%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/portals/</link><pubDate>Fri, 16 Jul 2021 00:00:00 +0000</pubDate><guid>https://blog.visionary.top/blog/react%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/portals/</guid><description>写法在内部 实际渲染在同级 Example: Portals - by Dan Abramov</description></item><item><title>react 源码阅读 - Hooks</title><link>https://blog.visionary.top/blog/react%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/hooks/</link><pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate><guid>https://blog.visionary.top/blog/react%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/hooks/</guid><description>有那些hooks
useState useReducer ##useEffect
##useContext
##useRef</description></item><item><title>react &amp; reactDOM API</title><link>https://blog.visionary.top/blog/react%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/reactbasic/</link><pubDate>Fri, 02 Apr 2021 00:00:00 +0000</pubDate><guid>https://blog.visionary.top/blog/react%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/reactbasic/</guid><description>react v17.0.2 概述 react 整个项目的架构
读源码的有什么用
react react-dom React Top-Level API Components
React.Component 使用方式 class Welcome extends React.Component { render() { return &amp;lt;h1&amp;gt;Hello, {this.props.name}&amp;lt;/h1&amp;gt;; } } &amp;lt;Welcome/&amp;gt; 源码
function Component(props, context, updater) { this.props = props; this.context = context; // If a component has string refs, we will assign a different object later. this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the // renderer.</description></item><item><title>react 源码阅读 - diff 算法</title><link>https://blog.visionary.top/blog/react%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/diff%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 02 Apr 2021 00:00:00 +0000</pubDate><guid>https://blog.visionary.top/blog/react%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/diff%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid><description>详细写了 diff 算法的原理，写了示例，分析了源码，加了注释
// TODO 有空加一个可debug的demo 还有 模拟一个可test的简易diff
可检查[1,2,3] [{props:{children:[]},next:''},{},{}]
版本 v17.0.2 diff 算法只对同级元素进行
diff算法比较的是什么 当前页面中的DOM节点对应的fiber节点 🆚 新一次render的结果生成的filter节点 生成的workInProgress Fiber 将被渲染到页面 diff算法的作用 找到可复用的fiber节点，提高效率 diff算法由什么触发 reconcile child fibers diff算法在哪个阶段执行 diff 就是在 遍历 - 打标记，知道resultingFirstChild 记录了新的fiber树 // TODO // new children debug看一下 // oldFiber debug看一下
单节点 / 调和单节点 对于object/number/string
先检查上次更新时fiber节点是否存在对应DOM - 即检查是不是首次渲染，渲染过才有DOM
如果不存在对应DOM，则直接新生成新节点返回
要是存在对应DOM，继续检查是否可复用 - key &amp;amp; type相同
可复用的话，将节点新生成一个副本返回
不可复用的话，将DOM标记为需要删除，再新生成节点返回
&amp;lt;div&amp;gt;old&amp;lt;/div&amp;gt; // ⬇️ type &amp;amp; key = null 没变; children改变，div 可复用，标记child需要更新 &amp;lt;div&amp;gt;new&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;old&amp;lt;/div&amp;gt; // ⬇️ type改变 直接标记div为delection 新生成 p-&amp;gt; new 返回 &amp;lt;p&amp;gt;new&amp;lt;/p&amp;gt; &amp;lt;div key=&amp;#34;old&amp;#34;&amp;gt;old&amp;lt;/div&amp;gt; // ⬇️ key 改变 不可复用 &amp;lt;div key=&amp;#34;new&amp;#34;&amp;gt;old&amp;lt;/div&amp;gt; 多节点 对于 array</description></item><item><title>react 源码阅读 - setState</title><link>https://blog.visionary.top/blog/react%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/setstate/</link><pubDate>Fri, 02 Apr 2021 00:00:00 +0000</pubDate><guid>https://blog.visionary.top/blog/react%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/setstate/</guid><description>Component.prototype.setState = function (partialState, callback) { this.updater.enqueueSetState(this, partialState, callback, &amp;#39;setState&amp;#39;); }; function enqueueSetState(inst, payload, callback) { // ... // 存在来updatel里 update.payload = payload; // 将update插入updateQueue // 调度update enqueueUpdate(fiber, update, lane); scheduleUpdateOnFiber(fiber, lane, eventTime); }</description></item><item><title>react 源码阅读 - show with code</title><link>https://blog.visionary.top/blog/react%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/react%E7%BB%93%E5%90%88%E5%AE%9E%E6%88%98/</link><pubDate>Fri, 02 Apr 2021 00:00:00 +0000</pubDate><guid>https://blog.visionary.top/blog/react%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/react%E7%BB%93%E5%90%88%E5%AE%9E%E6%88%98/</guid><description/></item><item><title>react 源码阅读 - ssr</title><link>https://blog.visionary.top/blog/react%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/</link><pubDate>Fri, 02 Apr 2021 00:00:00 +0000</pubDate><guid>https://blog.visionary.top/blog/react%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/</guid><description/></item><item><title>react 源码阅读 - 名词 &amp; 数据结构</title><link>https://blog.visionary.top/blog/react%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/react%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%90%8D%E8%AF%8D/</link><pubDate>Fri, 02 Apr 2021 00:00:00 +0000</pubDate><guid>https://blog.visionary.top/blog/react%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/react%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%90%8D%E8%AF%8D/</guid><description/></item><item><title>react 源码阅读 - 流程</title><link>https://blog.visionary.top/blog/react%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/react%E6%B5%81%E7%A8%8B/</link><pubDate>Fri, 02 Apr 2021 00:00:00 +0000</pubDate><guid>https://blog.visionary.top/blog/react%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/react%E6%B5%81%E7%A8%8B/</guid><description>&lt;p>React16架构&lt;/p>
&lt;ul>
&lt;li>scheduler 调度 【v15没有】
&lt;blockquote>
&lt;p>调度任务的优先级，高优任务优先进入Reconciler
到底是怎么调度的？
react v18的并发模式 Concurrent Mode&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>reconciler 协调
&lt;blockquote>
&lt;p>负责找出变化的组件&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>renderer 渲染
&lt;blockquote>
&lt;p>负责将变化的组件渲染到页面上&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul></description></item></channel></rss>