<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>数据结构 on VISIONARY</title><link>https://visionary.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><description>Recent content in 数据结构 on VISIONARY</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 16 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://visionary.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml"/><item><title>Curry Function - 柯里化函数</title><link>https://visionary.top/blog/algorithms/curry_function/</link><pubDate>Fri, 16 Jul 2021 00:00:00 +0000</pubDate><guid>https://visionary.top/blog/algorithms/curry_function/</guid><description>Curry Function Currying is a process in functional programming in which we can transform a function with multiple arguments into a sequence of nesting functions. It returns a new function that expects the next argument inline.
function multiply(a) { return (b) =&amp;gt; { return (c) =&amp;gt; { return a * b * c } } } log(multiply(1)(2)(3)) // 6 柯里化是一种函数的转换，它是指将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)(c)。
柯里化不会调用函数。它只是对函数进行转换。
function curry(fn, ...args) { return (.</description></item><item><title>双向链表</title><link>https://visionary.top/blog/algorithms/doublylinkedlist/</link><pubDate>Fri, 16 Jul 2021 00:00:00 +0000</pubDate><guid>https://visionary.top/blog/algorithms/doublylinkedlist/</guid><description>export default class DoublyLinkedListNode { constructor(value, next = null, previous = null) { this.value = value; this.next = next; this.previous = previous; } toString(callback) { return callback ? callback(this.value) : `${this.value}`; } }</description></item><item><title>链表</title><link>https://visionary.top/blog/algorithms/linkedlist/</link><pubDate>Fri, 16 Jul 2021 00:00:00 +0000</pubDate><guid>https://visionary.top/blog/algorithms/linkedlist/</guid><description>&lt;p>使用js实现链表&lt;/p></description></item></channel></rss>