<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>react 源码阅读 - diff 算法 - VISIONARY</title><meta name=generator content="Hugo 0.94.2"><link rel=stylesheet href="https://visionary.top/css/styles.min.ec6ba89a06bf6fa69af8ca4da0bd1246456266abd1b4f130627e256c5123938c.css" integrity="sha256-7Guomga/b6aa+MpNoL0SRkViZqvRtPEwYn4lbFEjk4w="><script>window.matchMedia("(prefers-color-scheme: dark)").matches?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark")</script><script data-ad-client=ca-pub-6431705402019390 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body class="flex flex-col min-h-screen dark:bg-gray-900 dark:text-gray-100 transition-colors duration-500"><header class="w-full px-4 pt-4 max-w-5xl mx-auto"><nav class="flex items-center justify-between flex-wrap"><div class="flex gap-2 items-center"><a href=mailto:min_0610@icloud.com aria-label=EMail><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="4"/><path d="M16 12v1.5a2.5 2.5.0 005 0V12a9 9 0 10-5.5 8.28"/></svg></a><a href=https://visionary.top/ class="flex items-center font-bold">VISIONARY</a></div><ul id=nav-menu class="flex w-auto mt-0 space-x-2"><li><div class=search><label for=search>🔍</label><input placeholder=SEARCH id=search type=text class=dark:bg-gray-900><ul id=results class=search_result></ul></div><script type=text/javascript src=https://code.jquery.com/jquery-2.1.3.min.js></script>
<script type=text/javascript src=/js/lunr/lunr.min.js></script>
<script type=text/javascript>let lunrIndex,$results,pagesIndex;function initLunr(){$.getJSON("/js/lunr/PagesIndex.json").done(function(e){pagesIndex=e,console.info("index:",pagesIndex),lunrIndex=lunr(function(){this.field("title",{boost:10}),this.field("tags",{boost:5}),console.log(this.add),this.field("content"),this.ref("href"),pagesIndex.forEach(e=>{console.log(e),e&&this.add(e)})})}).fail(function(s,e,t){const n=e+", "+t;console.error("Error getting Hugo index flie:",n)})}function initUI(){$results=$("#results"),$("#search").keyup(function(){$results.empty();const e=$(this).val();if(e.length<2)return;const t=search(e);renderResults(t)})}function search(e){return lunrIndex.search(e).map(function(e){return console.log(e),pagesIndex.filter(function(t){return t&&t.href===e.ref})[0]})}function renderResults(e){if(!e.length)return;e.slice(0,10).forEach(function(e){const t=$("<li>");t.append($("<a>",{href:e?e.href:'',text:"🔗 "+e.title})),$results.append(t)})}initLunr(),$(document).ready(function(){initUI()})</script></li><li><a href=https://visionary.top/tags/about/ class="hover:text-blue-800 dark:hover:text-blue-300">About</a></li><li><a href=https://visionary.top/blog/ class="hover:text-blue-800 dark:hover:text-blue-300">Blogs</a></li></ul></nav></header><main class="flex-1 mx-4 md:mx-12 lg:mx-24 mt-8 sm:mt-16"><article class="mb-16 max-w-5xl mx-auto px-4" style=position:relative><h1 class="text-5xl mb-6">react 源码阅读 - diff 算法</h1><ul></ul><div class="post-footer mb-6"><div class=info><span class=separator><a class=category href=/categories/react/>react</a><a class=category href=/categories/%E6%BA%90%E7%A0%81/>源码</a></span></div></div><div class=post-footer></div><aside class=content-aside-bar><h2 class=text-xl>📚 目录</h2><nav id=TableOfContents><ul><li><a href=#版本-v1702>版本 v17.0.2</a><ul><li><a href=#单节点--调和单节点>单节点 / 调和单节点</a></li><li><a href=#多节点>多节点</a></li><li><a href=#这部分的代码在-react-reconciler>这部分的代码在 react-reconciler</a></li></ul></li></ul></nav></aside><div class="prose lg:prose-lg prose-blue dark:prose-dark"><p>版本 v17.0.2
单节点比较、多节点比较</p><p>详细写了 diff 算法的原理，写了示例，分析了源码，加了注释</p><p>// TODO 有空加一个可debu g的demo 还有 模拟一个可test的简易diff</p><p>可检查[1,2,3] [{props:{children:[]},next:&rsquo;&rsquo;},{},{}]</p><h2 id=版本-v1702>版本 v17.0.2</h2><p>diff 算法只对同级元素进行</p><ol><li>diff算法比较的是什么 当前页面中的DOM节点对应的fiber节点 🆚 新一次render的结果生成的filter节点 生成的workInProgress Fiber 将被渲染到页面</li><li>diff算法的作用 找到可复用的fiber节点，提高效率</li><li>diff算法由什么触发 reconcile child fibers</li><li>diff算法在哪个阶段执行</li><li>diff 就是在 遍历 - 打标记，知道resultingFirstChild 记录了新的fiber树</li></ol><p>// TODO
// new children debug看一下
// oldFiber debug看一下</p><h3 id=单节点--调和单节点>单节点 / 调和单节点</h3><p>对于object/number/string</p><p>先检查上次更新时fiber节点是否存在对应DOM - 即检查是不是首次渲染，渲染过才有DOM</p><p>如果不存在对应DOM，则直接新生成新节点返回</p><p>要是存在对应DOM，继续检查是否可复用 - key & type相同</p><p>可复用的话，将节点新生成一个副本返回</p><p>不可复用的话，将DOM标记为需要删除，再新生成节点返回</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span>&lt;<span style=color:#f92672>div</span>&gt;<span style=color:#a6e22e>old</span>&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span><span style=color:#75715e>// ⬇️ type &amp; key = null 没变; children改变，div 可复用，标记child需要更新
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>&lt;<span style=color:#f92672>div</span>&gt;<span style=color:#66d9ef>new</span>&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>div</span>&gt;<span style=color:#a6e22e>old</span>&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span><span style=color:#75715e>// ⬇️ type改变 直接标记div为delection 新生成 p-&gt; new 返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>&lt;<span style=color:#f92672>p</span>&gt;<span style=color:#66d9ef>new</span>&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>key</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;old&#34;</span>&gt;<span style=color:#a6e22e>old</span>&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span><span style=color:#75715e>// ⬇️ key 改变 不可复用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>key</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;new&#34;</span>&gt;<span style=color:#a6e22e>old</span>&lt;/<span style=color:#f92672>div</span>&gt;
</span></span></code></pre></div><h3 id=多节点>多节点</h3><p>对于 array</p><p>对 old array & new array 进行两次遍历</p><p>因为一般在业务中更新的情况要比增删的次数多</p><p>所以先处理更新的情况</p><ol><li>对于 array只有更新的情况</li></ol><p><img src=/assets/react/img_5.png alt=img_5.png></p><p>一次遍历即可结束 给要改变的节点打上标记</p><ol start=2><li>第一次遍历 old array没有了 - new array有剩余 - 新增</li></ol><p><img src=/assets/react/img_6.png alt=img_6.png></p><p>第一次遍历标记完更新之后，继续遍历new array剩余部分，都标记为 placement</p><ol start=3><li>第一次遍历 new array没有了 - old array有剩余 - 删除</li></ol><p><img src=/assets/react/img_8.png alt=img_8.png></p><p>继续遍历old array，都标记为deletion</p><ol start=4><li>第一次没有遍历完 - new array 和 old array 都有剩余</li></ol><p><img src=/assets/react/img_9.png alt=img_9.png></p><p>将 剩余的old array 生成 key -> fiber node 对应表； 方便new array 遍历时找对应的</p><blockquote><p>为什么需要unique key</p><p>当出现在头部插入的行为时，生成了对应表 之前的fiber node 就可以复用</p><p>要是 使用了index作为 key prop传来的值可以正常使用， state找的时候就不对 【还有input输入框这种的值】
（子组件自己的东西会出错）
复用的时候 key -> fiber node 对应的是错误的 0 - 0 => 0 - 1 , 1 - 0</p><p>在尾部插入时 index 相对来说是稳定的 就没有问题</p><p>排序的时候 index是没变化的 props 跟着变了 state还是对应的原来的index 就不会有变化</p></blockquote><div style=position:relative;overflow:hidden><div></div><h2></h2><h4><a class=text-gray-500 href=https://codepen.io/--/pen/ZEKjyRm>index 作为key</a>
- by <a href=https://codepen.io/viisionary>visionary💎</a></h4><iframe id=cp_embed_dPrEvP class=cp_embed_iframe style=width:100%;overflow:hidden src="https://codepen.io/--/embed/preview/ZEKjyRm?height=300&slug-hash=ZEKjyRm&default-tab=result&host=http%3A%2F%2Fcodepen.io" width=300 height=300 frameborder=0 scrolling=no></iframe></div><p>开始第二次循环，遍历剩余的 new array</p><p><img src=/assets/react/img_10.png alt=img_10.png></p><p>标记移动了、删除了、新增了的节点</p><p>hint：节点从后向前移消耗较大、因为标记不变的是1</p><p><img src=/assets/react/img_11.png alt=img_11.png></p><h3 id=这部分的代码在-react-reconciler>这部分的代码在 react-reconciler</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>packages/react-reconciler/src/ReactChildFiber.new.js
</span></span></code></pre></div><p>编译后集中到了 reactDOM.js</p><p>有两个方法 reconcileSinglePortal ？由ReactDOM.createPortal创建来的？ reconcileSingleElement</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// 去掉了一些dev代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>reconcileSingleElement</span>(
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>returnFiber</span>: <span style=color:#66d9ef>Fiber</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>currentFirstChild</span>: <span style=color:#66d9ef>Fiber</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>element</span>: <span style=color:#66d9ef>ReactElement</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lanes</span>: <span style=color:#66d9ef>Lanes</span>,
</span></span><span style=display:flex><span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Fiber</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>key</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>element</span>.<span style=color:#a6e22e>key</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>child</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>currentFirstChild</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 判断是否存在对应DOM节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>child</span> <span style=color:#f92672>!==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 上一次更新存在DOM节点，接下来判断是否可复用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 比较key是否相同
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>child</span>.<span style=color:#a6e22e>key</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>key</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// key相同，接下来比较type是否相同
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>elementType</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>element</span>.<span style=color:#66d9ef>type</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// TODO ??  React.Fragment这个类型的？
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>elementType</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>REACT_FRAGMENT_TYPE</span><span style=color:#75715e>/*0xeacb*/</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>child</span>.<span style=color:#a6e22e>tag</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>Fragment</span> <span style=color:#75715e>/* 这是一个常量 7*/</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>deleteRemainingChildren</span>(<span style=color:#a6e22e>returnFiber</span>, <span style=color:#a6e22e>child</span>.<span style=color:#a6e22e>sibling</span>);
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 可以复用，返回复用的fiber
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>existing</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useFiber</span>(<span style=color:#a6e22e>child</span>, <span style=color:#a6e22e>element</span>.<span style=color:#a6e22e>props</span>.<span style=color:#a6e22e>children</span>);
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>existing</span>.<span style=color:#66d9ef>return</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>returnFiber</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>existing</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// type相同 可复用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>child</span>.<span style=color:#a6e22e>elementType</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>elementType</span> <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Lazy types
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    (<span style=color:#a6e22e>enableLazyElements</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>elementType</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;object&#39;</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>elementType</span> <span style=color:#f92672>!==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>elementType</span>.<span style=color:#a6e22e>$$typeof</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>REACT_LAZY_TYPE</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>resolveLazy</span>(<span style=color:#a6e22e>elementType</span>) <span style=color:#f92672>===</span> <span style=color:#a6e22e>child</span>.<span style=color:#66d9ef>type</span>)
</span></span><span style=display:flex><span>                ) {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>deleteRemainingChildren</span>(<span style=color:#a6e22e>returnFiber</span>, <span style=color:#a6e22e>child</span>.<span style=color:#a6e22e>sibling</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>existing</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useFiber</span>(<span style=color:#a6e22e>child</span>, <span style=color:#a6e22e>element</span>.<span style=color:#a6e22e>props</span>);
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>existing</span>.<span style=color:#a6e22e>ref</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>coerceRef</span>(<span style=color:#a6e22e>returnFiber</span>, <span style=color:#a6e22e>child</span>, <span style=color:#a6e22e>element</span>);
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>existing</span>.<span style=color:#66d9ef>return</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>returnFiber</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>existing</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>// key相同但是type不同,将该fiber及其兄弟fiber标记为删除
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// TODO 为啥兄弟也删？
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * // 当前页面显示的
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 ul &gt; li * 3
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 // 这次需要更新的
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 ul &gt; p
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 p 为单一节点 type变了 要把旧的li全部删掉
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 */</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>deleteRemainingChildren</span>(<span style=color:#a6e22e>returnFiber</span>, <span style=color:#a6e22e>child</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// key不同，将该fiber标记为删除
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>deleteChild</span>(<span style=color:#a6e22e>returnFiber</span>, <span style=color:#a6e22e>child</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建新的filber 并返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>element</span>.<span style=color:#66d9ef>type</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>REACT_FRAGMENT_TYPE</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>created</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createFiberFromFragment</span>(
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>element</span>.<span style=color:#a6e22e>props</span>.<span style=color:#a6e22e>children</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>returnFiber</span>.<span style=color:#a6e22e>mode</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>lanes</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>element</span>.<span style=color:#a6e22e>key</span>,
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>created</span>.<span style=color:#66d9ef>return</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>returnFiber</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>created</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>created</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createFiberFromElement</span>(<span style=color:#a6e22e>element</span>, <span style=color:#a6e22e>returnFiber</span>.<span style=color:#a6e22e>mode</span>, <span style=color:#a6e22e>lanes</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>created</span>.<span style=color:#a6e22e>ref</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>coerceRef</span>(<span style=color:#a6e22e>returnFiber</span>, <span style=color:#a6e22e>currentFirstChild</span>, <span style=color:#a6e22e>element</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>created</span>.<span style=color:#66d9ef>return</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>returnFiber</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>created</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>reconcileChildrenArray</span>(
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>returnFiber</span>: <span style=color:#66d9ef>Fiber</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>currentFirstChild</span>: <span style=color:#66d9ef>Fiber</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lanes</span>: <span style=color:#66d9ef>Lanes</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>newChildren</span>: <span style=color:#66d9ef>Array</span>,
</span></span><span style=display:flex><span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Fiber</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>null</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//newChildren中每个组件进行比较的是current fiber，同级的Fiber节点是由sibling指针链接形成的单链表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//不支持双指针遍历。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//newChildren[0]与fiber比较，newChildren[1]与fiber.sibling
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>resultingFirstChild</span>: <span style=color:#66d9ef>Fiber</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>previousNewFiber</span>: <span style=color:#66d9ef>Fiber</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>oldFiber</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>currentFirstChild</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>lastPlacedIndex</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>newIdx</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>nextOldFiber</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 第一次遍历
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (; <span style=color:#a6e22e>oldFiber</span> <span style=color:#f92672>!==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>newIdx</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>newChildren</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>newIdx</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ------------ TODO 相同就比下一个兄弟？
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>oldFiber</span>.<span style=color:#a6e22e>index</span> <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>newIdx</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>nextOldFiber</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>oldFiber</span>;
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>oldFiber</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>nextOldFiber</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>oldFiber</span>.<span style=color:#a6e22e>sibling</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ------------ 打上更新标记
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>newFiber</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>updateSlot</span>(
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>returnFiber</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>oldFiber</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>newChildren</span>[<span style=color:#a6e22e>newIdx</span>],
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>lanes</span>,
</span></span><span style=display:flex><span>        );  
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 有不同的了 跳出循环
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>newFiber</span> <span style=color:#f92672>===</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>oldFiber</span> <span style=color:#f92672>===</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>oldFiber</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>nextOldFiber</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 处理副作用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>shouldTrackSideEffects</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// oldFiber有东西 不是null newFiber没了，old剩余部分标记删除
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>oldFiber</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>newFiber</span>.<span style=color:#a6e22e>alternate</span> <span style=color:#f92672>===</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>deleteChild</span>(<span style=color:#a6e22e>returnFiber</span>, <span style=color:#a6e22e>oldFiber</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 打个标记？？  placement 是要新增的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>lastPlacedIndex</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>placeChild</span>(<span style=color:#a6e22e>newFiber</span>, <span style=color:#a6e22e>lastPlacedIndex</span>, <span style=color:#a6e22e>newIdx</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// -------TODO ??
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>previousNewFiber</span> <span style=color:#f92672>===</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>resultingFirstChild</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>newFiber</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>previousNewFiber</span>.<span style=color:#a6e22e>sibling</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>newFiber</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>previousNewFiber</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>newFiber</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>oldFiber</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>nextOldFiber</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//----⬆️ 第一次遍历结束
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// newChildren遍历完了 // 删除剩下的兄弟&amp;children
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>newIdx</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>newChildren</span>.<span style=color:#a6e22e>length</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>deleteRemainingChildren</span>(<span style=color:#a6e22e>returnFiber</span>, <span style=color:#a6e22e>oldFiber</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 删除完毕 直接 return
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>resultingFirstChild</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//oldFiber 遍历完了 new 的还有
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>oldFiber</span> <span style=color:#f92672>===</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 继续遍历new的剩余部分
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (; <span style=color:#a6e22e>newIdx</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>newChildren</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>newIdx</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 创建新的fiber节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>newFiber</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createChild</span>(<span style=color:#a6e22e>returnFiber</span>, <span style=color:#a6e22e>newChildren</span>[<span style=color:#a6e22e>newIdx</span>], <span style=color:#a6e22e>lanes</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>newFiber</span> <span style=color:#f92672>===</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>lastPlacedIndex</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>placeChild</span>(<span style=color:#a6e22e>newFiber</span>, <span style=color:#a6e22e>lastPlacedIndex</span>, <span style=color:#a6e22e>newIdx</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>previousNewFiber</span> <span style=color:#f92672>===</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// TODO: Move out of the loop. This only happens for the first run.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#a6e22e>resultingFirstChild</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>newFiber</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>previousNewFiber</span>.<span style=color:#a6e22e>sibling</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>newFiber</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>previousNewFiber</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>newFiber</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// new array 协调完毕 直接return
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>resultingFirstChild</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 第二次遍历开始
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 剩余old array
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 将所有子级添加到键映射以进行快速查找
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>existingChildren</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>mapRemainingChildren</span>(<span style=color:#a6e22e>returnFiber</span>, <span style=color:#a6e22e>oldFiber</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (; <span style=color:#a6e22e>newIdx</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>newChildren</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>newIdx</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 生成key-fiber对应表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>newFiber</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>updateFromMap</span>(
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>existingChildren</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>returnFiber</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>newIdx</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>newChildren</span>[<span style=color:#a6e22e>newIdx</span>],
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>lanes</span>,
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>newFiber</span> <span style=color:#f92672>!==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>newFiber</span>.<span style=color:#a6e22e>alternate</span> <span style=color:#f92672>!==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>existingChildren</span>.<span style=color:#66d9ef>delete</span>(
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>newFiber</span>.<span style=color:#a6e22e>key</span> <span style=color:#f92672>===</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> <span style=color:#a6e22e>newIdx</span> : <span style=color:#66d9ef>newFiber.key</span>,
</span></span><span style=display:flex><span>                );
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 剩余old array打上删除标记
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>existingChildren</span>.<span style=color:#a6e22e>forEach</span>(<span style=color:#a6e22e>child</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>deleteChild</span>(<span style=color:#a6e22e>returnFiber</span>, <span style=color:#a6e22e>child</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>resultingFirstChild</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><div class=comments><h1 class="text-m my-2">COMMENTS</h1><script src=https://utteranc.es/client.js repo=viisionary/visionary issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></main><footer class="w-full text-center p-4 text-xs text-gray-400">copyright © 2021 - VISIONARY · All rights reserved</footer><script async src="https://www.googletagmanager.com/gtag/js?id=G-Z0FJ599SKS"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Z0FJ599SKS")</script></body></html>