<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>react 源码阅读 - diff 算法 - VISIONARY</title><meta name=generator content="Hugo 0.107.0"><link rel=stylesheet href="https://visionary.top/css/styles.min.be63640ce3e9d06f0dc0df16f69951c4932b52b98ec039822b7ee11b7da8674c.css" integrity="sha256-vmNkDOPp0G8NwN8W9plRxJMrUrmOwDmCK37hG32oZ0w="><script async>window.onload=e=>{console.log("执行",document.getElementById("theme")),document.getElementById("theme").addEventListener("click",()=>{if(document.documentElement.classList.contains("dark")){document.documentElement.classList.remove("dark");return}document.documentElement.classList.add("dark")},!1)}</script><script>window.matchMedia("(prefers-color-scheme: dark)").matches?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark")</script><script data-ad-client=ca-pub-6431705402019390 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body class="flex flex-col min-h-screen dark:bg-gray-900 dark:text-gray-100 transition-colors duration-500"><header class="w-full px-4 pt-4 max-w-5xl mx-auto"><nav class="flex items-center justify-between flex-wrap"><div class="flex gap-2 items-center"><a href=mailto:min_0610@icloud.com aria-label=EMail><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="4"/><path d="M16 12v1.5a2.5 2.5.0 005 0V12a9 9 0 10-5.5 8.28"/></svg></a><a href=https://visionary.top/ class="flex items-center font-bold">VISIONARY</a></div><ul id=nav-menu class="flex w-auto mt-0 space-x-2"><li><div class=search><label for=search>🔍</label><input placeholder=SEARCH id=search type=text class=dark:bg-gray-900><ul id=results class=search_result></ul></div><script type=text/javascript src=https://code.jquery.com/jquery-2.1.3.min.js></script>
<script type=text/javascript src=/js/lunr/lunr.min.js></script>
<script type=text/javascript>let lunrIndex,$results,pagesIndex;function initLunr(){$.getJSON("/js/lunr/PagesIndex.json").done(function(e){pagesIndex=e,console.info("index:",pagesIndex),lunrIndex=lunr(function(){this.field("title",{boost:10}),this.field("tags",{boost:5}),console.log(this.add),this.field("content"),this.ref("href"),pagesIndex.forEach(e=>{console.log(e),e&&this.add(e)})})}).fail(function(e,t,n){const s=t+", "+n;console.error("Error getting Hugo index flie:",s)})}function initUI(){$results=$("#results"),$("#search").keyup(function(){$results.empty();const e=$(this).val();if(e.length<2)return;const t=search(e);renderResults(t)})}function search(e){return lunrIndex.search(e).map(function(e){return console.log(e),pagesIndex.filter(function(t){return t&&t.href===e.ref})[0]})}function renderResults(e){if(!e.length)return;e.slice(0,10).forEach(function(e){const t=$("<li>");t.append($("<a>",{href:e?e.href:"",text:"🔗 "+e.title})),$results.append(t)})}initLunr(),$(document).ready(function(){initUI()})</script></li><li><a href=https://visionary.top/tags/about/ class="hover:text-blue-800 dark:hover:text-blue-300">About</a></li><li><a href=https://visionary.top/blog/ class="hover:text-blue-800 dark:hover:text-blue-300">Blogs</a></li><li id=theme title="Toggle Mode" style=cursor:pointer>Toggle</li></ul></nav></header><main class="flex-1 mx-4 md:mx-12 lg:mx-24 mt-8 sm:mt-16"><article class="mb-16 max-w-5xl mx-auto px-4" style=position:relative><h1 class="text-5xl mb-6">react 源码阅读 - diff 算法</h1><ul></ul><div class="post-footer mb-6"><div class=info><span class=separator><a class=category href=/categories/react/>react</a><a class=category href=/categories/%E6%BA%90%E7%A0%81/>源码</a></span></div></div><div class=post-footer></div><aside class=content-aside-bar><h2 class=text-xl>📚 目录</h2><nav id=TableOfContents><ul><li><a href=#版本-v1702>版本 v17.0.2</a><ul><li><a href=#单节点--调和单节点>单节点 / 调和单节点</a></li><li><a href=#多节点>多节点</a></li><li><a href=#这部分的代码在-react-reconciler>这部分的代码在 react-reconciler</a></li></ul></li></ul></nav></aside><div class="prose lg:prose-lg prose-blue dark:prose-dark"><p>版本 v17.0.2
单节点比较、多节点比较</p><p>详细写了 diff 算法的原理，写了示例，分析了源码，加了注释</p><p>// TODO 有空加一个可debu g的demo 还有 模拟一个可test的简易diff</p><p>可检查[1,2,3] [{props:{children:[]},next:&rsquo;&rsquo;},{},{}]</p><h2 id=版本-v1702>版本 v17.0.2</h2><p>diff 算法只对同级元素进行</p><ol><li>diff算法比较的是什么 当前页面中的DOM节点对应的fiber节点 🆚 新一次render的结果生成的filter节点 生成的workInProgress Fiber 将被渲染到页面</li><li>diff算法的作用 找到可复用的fiber节点，提高效率</li><li>diff算法由什么触发 reconcile child fibers</li><li>diff算法在哪个阶段执行</li><li>diff 就是在 遍历 - 打标记，知道resultingFirstChild 记录了新的fiber树</li></ol><p>// TODO
// new children debug看一下
// oldFiber debug看一下</p><h3 id=单节点--调和单节点>单节点 / 调和单节点</h3><p>对于object/number/string</p><p>先检查上次更新时fiber节点是否存在对应DOM - 即检查是不是首次渲染，渲染过才有DOM</p><p>如果不存在对应DOM，则直接新生成新节点返回</p><p>要是存在对应DOM，继续检查是否可复用 - key & type相同</p><p>可复用的话，将节点新生成一个副本返回</p><p>不可复用的话，将DOM标记为需要删除，再新生成节点返回</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span>&lt;<span style=color:#ff79c6>div</span>&gt;old&lt;/<span style=color:#ff79c6>div</span>&gt;
</span></span><span style=display:flex><span><span style=color:#6272a4>// ⬇️ type &amp; key = null 没变; children改变，div 可复用，标记child需要更新
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>&lt;<span style=color:#ff79c6>div</span>&gt;<span style=color:#ff79c6>new</span>&lt;/<span style=color:#ff79c6>div</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;<span style=color:#ff79c6>div</span>&gt;old&lt;/<span style=color:#ff79c6>div</span>&gt;
</span></span><span style=display:flex><span><span style=color:#6272a4>// ⬇️ type改变 直接标记div为delection 新生成 p-&gt; new 返回
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>&lt;<span style=color:#ff79c6>p</span>&gt;<span style=color:#ff79c6>new</span>&lt;/<span style=color:#ff79c6>p</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;<span style=color:#ff79c6>div</span> <span style=color:#50fa7b>key</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;old&#34;</span>&gt;old&lt;/<span style=color:#ff79c6>div</span>&gt;
</span></span><span style=display:flex><span><span style=color:#6272a4>// ⬇️ key 改变 不可复用
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>&lt;<span style=color:#ff79c6>div</span> <span style=color:#50fa7b>key</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;new&#34;</span>&gt;old&lt;/<span style=color:#ff79c6>div</span>&gt;
</span></span></code></pre></div><h3 id=多节点>多节点</h3><p>对于 array</p><p>对 old array & new array 进行两次遍历</p><p>因为一般在业务中更新的情况要比增删的次数多</p><p>所以先处理更新的情况</p><ol><li>对于 array只有更新的情况</li></ol><p><img src=/assets/react/img_5.png alt=img_5.png></p><p>一次遍历即可结束 给要改变的节点打上标记</p><ol start=2><li>第一次遍历 old array没有了 - new array有剩余 - 新增</li></ol><p><img src=/assets/react/img_6.png alt=img_6.png></p><p>第一次遍历标记完更新之后，继续遍历new array剩余部分，都标记为 placement</p><ol start=3><li>第一次遍历 new array没有了 - old array有剩余 - 删除</li></ol><p><img src=/assets/react/img_8.png alt=img_8.png></p><p>继续遍历old array，都标记为deletion</p><ol start=4><li>第一次没有遍历完 - new array 和 old array 都有剩余</li></ol><p><img src=/assets/react/img_9.png alt=img_9.png></p><p>将 剩余的old array 生成 key -> fiber node 对应表； 方便new array 遍历时找对应的</p><blockquote><p>为什么需要unique key</p><p>当出现在头部插入的行为时，生成了对应表 之前的fiber node 就可以复用</p><p>要是 使用了index作为 key prop传来的值可以正常使用， state找的时候就不对 【还有input输入框这种的值】
（子组件自己的东西会出错）
复用的时候 key -> fiber node 对应的是错误的 0 - 0 => 0 - 1 , 1 - 0</p><p>在尾部插入时 index 相对来说是稳定的 就没有问题</p><p>排序的时候 index是没变化的 props 跟着变了 state还是对应的原来的index 就不会有变化</p></blockquote><div style=position:relative;overflow:hidden><div></div><h2></h2><h4><a class=text-gray-500 href=https://codepen.io/--/pen/ZEKjyRm>index 作为key</a>
- by <a href=https://codepen.io/viisionary>visionary💎</a></h4><iframe id=cp_embed_dPrEvP class=cp_embed_iframe style=width:100%;overflow:hidden src="https://codepen.io/--/embed/preview/ZEKjyRm?height=300&slug-hash=ZEKjyRm&default-tab=result&host=http%3A%2F%2Fcodepen.io" width=300 height=300 frameborder=0 scrolling=no></iframe></div><p>开始第二次循环，遍历剩余的 new array</p><p><img src=/assets/react/img_10.png alt=img_10.png></p><p>标记移动了、删除了、新增了的节点</p><p>hint：节点从后向前移消耗较大、因为标记不变的是1</p><p><img src=/assets/react/img_11.png alt=img_11.png></p><h3 id=这部分的代码在-react-reconciler>这部分的代码在 react-reconciler</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>packages/react-reconciler/src/ReactChildFiber.new.js
</span></span></code></pre></div><p>编译后集中到了 reactDOM.js</p><p>有两个方法 reconcileSinglePortal ？由ReactDOM.createPortal创建来的？ reconcileSingleElement</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#6272a4>// 去掉了一些dev代码
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>function</span> reconcileSingleElement(
</span></span><span style=display:flex><span>    returnFiber: <span style=color:#8be9fd>Fiber</span>,
</span></span><span style=display:flex><span>    currentFirstChild: <span style=color:#8be9fd>Fiber</span> <span style=color:#ff79c6>|</span> <span style=color:#ff79c6>null</span>,
</span></span><span style=display:flex><span>    element: <span style=color:#8be9fd>ReactElement</span>,
</span></span><span style=display:flex><span>    lanes: <span style=color:#8be9fd>Lanes</span>,
</span></span><span style=display:flex><span>)<span style=color:#ff79c6>:</span> Fiber {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> key <span style=color:#ff79c6>=</span> element.key;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> child <span style=color:#ff79c6>=</span> currentFirstChild;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 判断是否存在对应DOM节点
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>while</span> (child <span style=color:#ff79c6>!==</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 上一次更新存在DOM节点，接下来判断是否可复用
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#6272a4>// 比较key是否相同
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>if</span> (child.key <span style=color:#ff79c6>===</span> key) {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// key相同，接下来比较type是否相同
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#ff79c6>const</span> elementType <span style=color:#ff79c6>=</span> element.<span style=color:#ff79c6>type</span>;
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// TODO ??  React.Fragment这个类型的？
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#ff79c6>if</span> (elementType <span style=color:#ff79c6>===</span> REACT_FRAGMENT_TYPE<span style=color:#6272a4>/*0xeacb*/</span>) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (child.tag <span style=color:#ff79c6>===</span> Fragment <span style=color:#6272a4>/* 这是一个常量 7*/</span>) {
</span></span><span style=display:flex><span>                    deleteRemainingChildren(returnFiber, child.sibling);
</span></span><span style=display:flex><span>                    <span style=color:#6272a4>// 可以复用，返回复用的fiber
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>                    <span style=color:#ff79c6>const</span> existing <span style=color:#ff79c6>=</span> useFiber(child, element.props.children);
</span></span><span style=display:flex><span>                    existing.<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>=</span> returnFiber;
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>return</span> existing;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// type相同 可复用
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>                <span style=color:#ff79c6>if</span> (child.elementType <span style=color:#ff79c6>===</span> elementType <span style=color:#ff79c6>||</span>
</span></span><span style=display:flex><span>                    <span style=color:#6272a4>// Lazy types
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>                    (enableLazyElements <span style=color:#ff79c6>&amp;&amp;</span>
</span></span><span style=display:flex><span>                        <span style=color:#ff79c6>typeof</span> elementType <span style=color:#ff79c6>===</span> <span style=color:#f1fa8c>&#39;object&#39;</span> <span style=color:#ff79c6>&amp;&amp;</span>
</span></span><span style=display:flex><span>                        elementType <span style=color:#ff79c6>!==</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span>
</span></span><span style=display:flex><span>                        elementType.$$typeof <span style=color:#ff79c6>===</span> REACT_LAZY_TYPE <span style=color:#ff79c6>&amp;&amp;</span>
</span></span><span style=display:flex><span>                        resolveLazy(elementType) <span style=color:#ff79c6>===</span> child.<span style=color:#ff79c6>type</span>)
</span></span><span style=display:flex><span>                ) {
</span></span><span style=display:flex><span>                    deleteRemainingChildren(returnFiber, child.sibling);
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>const</span> existing <span style=color:#ff79c6>=</span> useFiber(child, element.props);
</span></span><span style=display:flex><span>                    existing.ref <span style=color:#ff79c6>=</span> coerceRef(returnFiber, child, element);
</span></span><span style=display:flex><span>                    existing.<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>=</span> returnFiber;
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>return</span> existing;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// key相同但是type不同,将该fiber及其兄弟fiber标记为删除
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>                <span style=color:#6272a4>// TODO 为啥兄弟也删？
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>                <span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4>                 * // 当前页面显示的
</span></span></span><span style=display:flex><span><span style=color:#6272a4>                 ul &gt; li * 3
</span></span></span><span style=display:flex><span><span style=color:#6272a4>
</span></span></span><span style=display:flex><span><span style=color:#6272a4>                 // 这次需要更新的
</span></span></span><span style=display:flex><span><span style=color:#6272a4>                 ul &gt; p
</span></span></span><span style=display:flex><span><span style=color:#6272a4>                 p 为单一节点 type变了 要把旧的li全部删掉
</span></span></span><span style=display:flex><span><span style=color:#6272a4>                 */</span>
</span></span><span style=display:flex><span>                deleteRemainingChildren(returnFiber, child);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// key不同，将该fiber标记为删除
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            deleteChild(returnFiber, child);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 创建新的filber 并返回
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> (element.<span style=color:#ff79c6>type</span> <span style=color:#ff79c6>===</span> REACT_FRAGMENT_TYPE) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>const</span> created <span style=color:#ff79c6>=</span> createFiberFromFragment(
</span></span><span style=display:flex><span>            element.props.children,
</span></span><span style=display:flex><span>            returnFiber.mode,
</span></span><span style=display:flex><span>            lanes,
</span></span><span style=display:flex><span>            element.key,
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>        created.<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>=</span> returnFiber;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> created;
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>const</span> created <span style=color:#ff79c6>=</span> createFiberFromElement(element, returnFiber.mode, lanes);
</span></span><span style=display:flex><span>        created.ref <span style=color:#ff79c6>=</span> coerceRef(returnFiber, currentFirstChild, element);
</span></span><span style=display:flex><span>        created.<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>=</span> returnFiber;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> created;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> reconcileChildrenArray(
</span></span><span style=display:flex><span>    returnFiber: <span style=color:#8be9fd>Fiber</span>,
</span></span><span style=display:flex><span>    currentFirstChild: <span style=color:#8be9fd>Fiber</span> <span style=color:#ff79c6>|</span> <span style=color:#ff79c6>null</span>,
</span></span><span style=display:flex><span>    lanes: <span style=color:#8be9fd>Lanes</span>,
</span></span><span style=display:flex><span>    newChildren: <span style=color:#8be9fd>Array</span>,
</span></span><span style=display:flex><span>)<span style=color:#ff79c6>:</span> Fiber <span style=color:#ff79c6>|</span> <span style=color:#ff79c6>null</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//newChildren中每个组件进行比较的是current fiber，同级的Fiber节点是由sibling指针链接形成的单链表
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>//不支持双指针遍历。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>//newChildren[0]与fiber比较，newChildren[1]与fiber.sibling
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#8be9fd;font-style:italic>let</span> resultingFirstChild: <span style=color:#8be9fd>Fiber</span> <span style=color:#ff79c6>|</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> previousNewFiber: <span style=color:#8be9fd>Fiber</span> <span style=color:#ff79c6>|</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> oldFiber <span style=color:#ff79c6>=</span> currentFirstChild;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> lastPlacedIndex <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> newIdx <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> nextOldFiber <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 第一次遍历
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>for</span> (; oldFiber <span style=color:#ff79c6>!==</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> newIdx <span style=color:#ff79c6>&lt;</span> newChildren.length; newIdx<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// ------------ TODO 相同就比下一个兄弟？
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>if</span> (oldFiber.index <span style=color:#ff79c6>&gt;</span> newIdx) {
</span></span><span style=display:flex><span>            nextOldFiber <span style=color:#ff79c6>=</span> oldFiber;
</span></span><span style=display:flex><span>            oldFiber <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            nextOldFiber <span style=color:#ff79c6>=</span> oldFiber.sibling;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// ------------ 打上更新标记
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>const</span> newFiber <span style=color:#ff79c6>=</span> updateSlot(
</span></span><span style=display:flex><span>            returnFiber,
</span></span><span style=display:flex><span>            oldFiber,
</span></span><span style=display:flex><span>            newChildren[newIdx],
</span></span><span style=display:flex><span>            lanes,
</span></span><span style=display:flex><span>        );  
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 有不同的了 跳出循环
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>if</span> (newFiber <span style=color:#ff79c6>===</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (oldFiber <span style=color:#ff79c6>===</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>                oldFiber <span style=color:#ff79c6>=</span> nextOldFiber;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 处理副作用
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>if</span> (shouldTrackSideEffects) {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// oldFiber有东西 不是null newFiber没了，old剩余部分标记删除
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#ff79c6>if</span> (oldFiber <span style=color:#ff79c6>&amp;&amp;</span> newFiber.alternate <span style=color:#ff79c6>===</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>                deleteChild(returnFiber, oldFiber);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 打个标记？？  placement 是要新增的
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        lastPlacedIndex <span style=color:#ff79c6>=</span> placeChild(newFiber, lastPlacedIndex, newIdx);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// -------TODO ??
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>if</span> (previousNewFiber <span style=color:#ff79c6>===</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>            resultingFirstChild <span style=color:#ff79c6>=</span> newFiber;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            previousNewFiber.sibling <span style=color:#ff79c6>=</span> newFiber;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        previousNewFiber <span style=color:#ff79c6>=</span> newFiber;
</span></span><span style=display:flex><span>        oldFiber <span style=color:#ff79c6>=</span> nextOldFiber;
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//----⬆️ 第一次遍历结束
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    }
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// newChildren遍历完了 // 删除剩下的兄弟&amp;children
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> (newIdx <span style=color:#ff79c6>===</span> newChildren.length) {
</span></span><span style=display:flex><span>        deleteRemainingChildren(returnFiber, oldFiber);
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 删除完毕 直接 return
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>return</span> resultingFirstChild;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//oldFiber 遍历完了 new 的还有
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> (oldFiber <span style=color:#ff79c6>===</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 继续遍历new的剩余部分
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>for</span> (; newIdx <span style=color:#ff79c6>&lt;</span> newChildren.length; newIdx<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 创建新的fiber节点
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#ff79c6>const</span> newFiber <span style=color:#ff79c6>=</span> createChild(returnFiber, newChildren[newIdx], lanes);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (newFiber <span style=color:#ff79c6>===</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            lastPlacedIndex <span style=color:#ff79c6>=</span> placeChild(newFiber, lastPlacedIndex, newIdx);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (previousNewFiber <span style=color:#ff79c6>===</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// TODO: Move out of the loop. This only happens for the first run.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>                resultingFirstChild <span style=color:#ff79c6>=</span> newFiber;
</span></span><span style=display:flex><span>            } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>                previousNewFiber.sibling <span style=color:#ff79c6>=</span> newFiber;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            previousNewFiber <span style=color:#ff79c6>=</span> newFiber;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// new array 协调完毕 直接return
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>return</span> resultingFirstChild;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 第二次遍历开始
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 剩余old array
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 将所有子级添加到键映射以进行快速查找
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>const</span> existingChildren <span style=color:#ff79c6>=</span> mapRemainingChildren(returnFiber, oldFiber);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (; newIdx <span style=color:#ff79c6>&lt;</span> newChildren.length; newIdx<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 生成key-fiber对应表
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>const</span> newFiber <span style=color:#ff79c6>=</span> updateFromMap(
</span></span><span style=display:flex><span>            existingChildren,
</span></span><span style=display:flex><span>            returnFiber,
</span></span><span style=display:flex><span>            newIdx,
</span></span><span style=display:flex><span>            newChildren[newIdx],
</span></span><span style=display:flex><span>            lanes,
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (newFiber <span style=color:#ff79c6>!==</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (newFiber.alternate <span style=color:#ff79c6>!==</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>                existingChildren.<span style=color:#ff79c6>delete</span>(
</span></span><span style=display:flex><span>                    newFiber.key <span style=color:#ff79c6>===</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>?</span> newIdx : <span style=color:#8be9fd>newFiber.key</span>,
</span></span><span style=display:flex><span>                );
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 剩余old array打上删除标记
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    existingChildren.forEach(child <span style=color:#ff79c6>=&gt;</span> deleteChild(returnFiber, child));
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> resultingFirstChild;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><div class=comments><h1 class="text-m my-2">COMMENTS</h1><script src=https://utteranc.es/client.js repo=viisionary/visionary issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></main><footer class="w-full text-center p-4 text-xs text-gray-400">copyright © 2021 - VISIONARY · All rights reserved</footer><script async src="https://www.googletagmanager.com/gtag/js?id=G-Z0FJ599SKS"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Z0FJ599SKS")</script></body></html>